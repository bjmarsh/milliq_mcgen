## Master milliQan MC generation tutorial
The full milliQan simulation pipeline involves numerous steps, pulling from multiple repositories written by multiple people. The initial event generation is handled by this repository, the propagation engine is in [MilliqanSim](https://github.com/bjmarsh/MilliqanSim), Geant4 simulation and ntuplization is in [milliQanDemoSim](https://github.com/milliQan-sw/milliQanDemoSim), and pulse injection is handled by macros in [milliqanOffline](https://github.com/milliQan-sw/milliqanOffline). Various scripts for analysis, plotting, and deriving calibrations/systematics are scattered across these repositories.

Here I've tried to organize everything into a single place, to provide some kind of instruction for anyone in the future trying to run through this whole process.

### Event Generation
Generation of initial events (mCPs or beam muons) is handled by this [milliq_mcgen](https://github.com/bjmarsh/milliq_mcgen) repository. First, we consider mCPs. Cross sections and p<sub>T</sub> distributions for all of the various production modes come from different places. All of these should already be in place in a fresh clone of the repository, and you can proceed straight to the generation, but I list them here for reference.
* Light meson production is done with pythia. All use the pythia8 Monash2013 tune, except for &phi;s which use the pythia6 DW tune. Instructions/scripts for running pythia and generating the p<sub>T</sub> distributions can be found in the [mesonPt](../mesonPt) directory. The output is a set of histograms with units of "particles per minbias event per 50 MeV bin" (for the eta range |&eta;|<2). So, the total cross section for a given particle is the sum of all bin contents ("particles per minbias event") times the MinBias cross section. The histograms used in the demonstrator paper are in [pt_dists.root](../mesonPt/pt_dists.root).
* J/&psi; and &psi;' production come from theory. We have merged together separate low-p<sub>T</sub> and high-p<sub>T</sub> files; see [oniaDirect/CMS-13-TeV/theory/psiLowPt](../oniaDirect/CMS-13-TeV/theory/psiLowPt) for the scripts and merged files (merged_*.root). These files contain d&sigma;/dp<sub>T</sub> histograms, for |&eta;|<1.2.
* Upsilon production comes from experiment (high-p<sub>T</sub> from 13 TeV ATLAS data, low-p<sub>T</sub> from 7 TeV CMS data). See [oniaDirect/upsilon](../oniaDirect/upsilon) for scripts and merged files (ups*_combined.root). The histograms again contain d&sigma;/dp<sub>T</sub> for |&eta;|<1.2, but this time the branching ratios to &mu;&mu; are folded in; this is divided out in the generation stage).
* Drell-Yan is taken from MadGraph. See the [madgraphDY](../madgraphDY) directory for instructions. For the purposes of the demonstrator paper, since DY is subdominant everywhere important, it was sufficient to run jobs locally overnight with the `parallel` utility. For higher stats/more mass points, grid submission will probably need to be implemented.

For all non-DY modes, we need to convert the differential cross section distributions into ntuples of generated mCPs. This is done with the tools in the [decayMCP](../decayMCP) directory. `DecayGen` is a class that interfaces with the various histograms described above, extracts total cross sections/BRs, and performs the decays. It shouldn't need to be touched unless you change the format of cross section histograms (or want to change hardcoded MinBias xsec at the top). The ntuples are generated with `runDecays`, following the instructions in [decayMCP](../decayMCP). It produces an `MCPTree`, with branches described in the README.

For a full production, it is easiest to submit jobs to the grid. Scripts and instructions are in [decayMCP/localbatch](../decayMCP/localbatch). These scripts automatically adjust the number of events in each production mode so that event weights are ~constant (i.e. # of events is proportional to xsec*BR). If this is done correctly, you should have a hadoop directory structured as `<mass_dir>/<mode_dir>/output_*.root` with MCPTrees in the ROOT files.

**Misc:** C++ files containing the functions used to compute branching ratios and do the four-vector decay math are in [utils](../utils). Python versions (not really used for anything any more) are in [scripts](../scripts). These shouldn't need to be touched unless you find a bug (hopefully not, since we will have published with that bug....). Scripts to generate a ROOT file with mCP cross sections and turn these into the [xsec plot used in the paper](../scripts/plot-xsecs/mcp-xsec.pdf) are in [scripts/plot-xsecs](../scripts/plot-xsecs).

**Muons:** The equivalent event generation for muons is in the [muons](../muons) directory. Cross section data for the various modes is in [muons/data](../muons/data). The QCD modes come from pythia, using the same tools as described above. Batch submission tools are in [muons/localbatch](../muons/localbatch). Note that it is currently set up pretty inefficiently, as it generates the same number of events for each mode even though the QCD modes have much higher cross sections than the W/Z modes. For the future someone should fix this to generate in rough proportion to the total cross sections, like I did for mCPs.

### Propagation

Once we have the generated events, we need to propagate them to the milliQan detector. The propagation engine that drives this is in the [MilliqanSim](https://github.com/bjmarsh/MilliqanSim) repository; details can be found there. This repository contains a wrapper around this in the [propagate](../propagate) directory. This takes the output ntuples from the previous step, propagates them to the milliQan detector, and adds relevant branches to the tree. General instructions are in the README there.

`config.py` contains the configurations that specify the location (eta/phi/R) of detector, the amount of rock, etc. The `det_width` and `det_height` parameters control the size of the rectangle in which to save particles. If a trajectory does not hit this rectangle, the event is thrown away. The `MilliqanDetector` object in `run_sim.py` controls the bar/slab arrangement (this doesn't really matter if you're just going to run through Geant; I've used this in the past as a "fast simulation" to get quick numbers for rates of signal going through bars, not accounting for detection efficiency).

The [propagate/batchsubmit](../propagate/batchsubmit) directory has scripts for batch submission of the entire mass/charge grid. `makeConfigFile.py` will generate a condor submission file for each (m,q) point, organized into directories. You will have to edit some parameters at the top: `ntuple_tag` is the tag of the gen ntuples you made in the previous step, `sim_tag` is whatever you want to tag this propagation, `config` should be "MQ" for default MilliQan, `dens_mult` scales all material densities by a fixed number (for deriving a systematic), and `save_dist` is the distance in meters before the milliqan detector face you want to save mCP trajectories. You'll also have to edit indir/outdirs because my username is hardcoded. Once you run this, you can run `. submit_all.sh configs/<ntuple_tag>_<sim_tag>` to submit all config files with condor. I probably should have set this up with [metis](https://github.com/aminnj/ProjectMetis), but I didn't. So for a very hacky way of monitoring jobs/automatically resubmitting failures, open a screen session and run `python checkAllConfig.py configs/<ntuple_tag>_<sim_tag>`.

For muons, you can run a similar procedure with `makeMuonConfigFile.py`.

The [propagate/scripts](../propagate/scripts) directory has a mess of scripts for handling/analyzing this propagation output. `. merge.sh <ntuple_tag> <sim_tag>` will merge the files (edit outdir since I am hardcoded). `. skim.sh <ntuple_tag> <sim_tag>` can apply a skim to these, which I used to restrict to a smaller rectangle before passing to Geant. `root2text.py` will turn the skimmed ROOT files into the text files that are currently required by the Geant sim.

Running `get_rates.py` then `plot_rates.py` will make useful plots like [these](http://uaf-8.t2.ucsd.edu/~bemarsh/milliqan/milliq_mcgen/plots/rate/v8_v1_save2m/) that plot the rates of incidence, either just hitting the defined rectangle ("rate") or going through three bars in a line ("line_rate"). `plot_kinematics.py` will make plots of various quantities for mCPs that make it to the detector, like [these](http://uaf-8.t2.ucsd.edu/~bemarsh/milliqan/milliq_mcgen/plots/kinematics/v6_v1/q_0p1/). `plot_etaphi.py` will dump plots of the initial eta/phi/pt of mCPs that hit detector, along with vertical dashed lines that indicate the generation bounds (like [this](http://uaf-8.t2.ucsd.edu/~bemarsh/milliqan/milliq_mcgen/plots/etaphi/v7/m_1p0/q_0p05/)). **You should make sure that the cuts don't cut off the distributions, or else you are excluding some of the rate**. I checked this for demonstrator, but if detector location/size is changed, you should check that they are still good (the place to change the actual cuts is in `runDecays.cc` from the generation step).

`muon_plots.py` will make useful plots of muons that make it to the detector, like [this](http://uaf-8.t2.ucsd.edu/~bemarsh/milliqan/milliq_mcgen/plots/muons/v5_v6_save2m/).

The `muangles` directory has scripts to do the rough check of muon angular distribution, like [this](http://uaf-8.t2.ucsd.edu/~bemarsh/milliqan/geant_sim/muangles/test/geantsim_run3_franny_data/top.pdf).

### Geant4 simulation

### Geant ntuplization

### Pulse injection
